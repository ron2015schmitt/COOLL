



FULL MULTIVECTORS SUPPORT

EXISTING PROBLEMS
* allow all existing complex overloaded funcs to still work for stuff like LAvector<LAvector<complex<D>> + LAvector<LAvector<D> >, etc.

* need to resolve problem where (for example) D*LAvector<LAvector<D>> wont compile because container doesn't hold type D.  Perhaps by havign templates D versus BotD to be same 

* need to be able to specialize to p3vector or LAvector and to know of what type an expression is of

best guess at a soluton is to add a new template parm to VorE which
defines teh toplevel container.  then change "D" parameter so that it
defines bottom level data type (built in such as int, bool, double,
complex).  ie. change VorE to have two new template parameters: VorE enum type (would give LAvector or p3vector), bottom datatype

* need to create a general vector class between VorE and LAvector,p3vector. call it storage_vector

   1. create size template class that has element structure such that
      can init via {3,4,5} etc.

   2. look into if it will work to put sizetype={1,2,3}

   3. create error checking class that can verify proper use of
      multilevel (i.e only allow LAvectors, p3vectors, complex,
      double, float, long double, short,long, long long, long long
      long, bool, etc.) NO std:: containers.  strategy is to traverse
      until a fundamental type. all types encountered must be known



MULTIVECTOR STREAMLINING

   4. change old constructors and change to {N} as input

   5. change resize to use {} class and be recursive

   6. add macros for 2D , 3D, 4D

   7. change all example code, testbed, errorex, benchmark code to use
      new contructors and resize?? better to create a special
      constructor for single depth versions using some sort of
      inheritance "add-in" or run-time errors when vector is
      multi-depth

   8. error checking placeholders

   9. string naming and the directory?

  10. example file

  11. testbed: test sin(x), +, - etc. for 2 deep and 3 deep

  add right() function and slice indexing function

    * LAvectors implement multilevel dot3(), cross(), .x(), .y(),
     .z(). this will require some helper classes and run-time errors
     will probably need to be used instead of compile errors
  - fix specialization functions for p3vector so that they work for 
    expressions too and use expression templates
 

NEW COMPLEX CLASS
    * implement Complex class that inherits from std::complex (so that
    * can leave all existing functions as std::complex and it will
    * work for both Complex will allow re, im access by reference.
    * add real complex interaction operators. eg. real*complex
    * create imaginary<D> class similar to complex class but has only
    * one piece of data 
    * real/imaginary math operators create real/complex and
    * imag/complex math operators
    * create support for imaginary vectors and matrices
    * create a unit imaginary class that is a subclass of Imaginary
      all members of this class are equal to 1. user can 
      instantiate as whatever name desirable. 
      optimize math for this class, for example, 5.0*ui would
      just return imaginary=5.0 w/o performing multiplication.
   * support different text formats, such as {R,I} or R+i*I (matlab)
   * this class may allow the removal of some of the specific code
   * for LAvector and matrices
 
LAPACK
- in place transpose for fortran
- det, inv, eigendecomp using lapack 

- testbench for math functions

SPARSE MATRICES
- sparse matrices
- diagonal matrices as subclass of sparse matrices. optimize dot
product
- constant diagonal matrices as subclass of sparse.  optimize dot
product.

OTHER FUNCTIONS
- matrix sortbyrow, sortbycol (allow user to specify which rows to
use, default is to use all in order)
- concat vectors or matrices (need methodology for this)
- repvector, repmat
- allow user to access valarray?
- binary load/save
- logspace function 


SPEED ISSUES
- implement disposable objects.  (add "disposable" flag for vectors
and matrices) then set for all intermediates.  implement disposable
copy which just swaps pointers between the assignee and assigned.

COMPILER SPEED ISSUES
- can we instantiate some objects in the library .cpp files to precompile some functions?
- can we use pure functions for make_type_string? this template wastes a lot of time

OTHER STUF

    * change all <class ...> to <typename ...>in templates change all
    * thoguht about changing D variables in functions to D& so as to speed multilevel, but classes are automatically referenced, so this should be left as is


