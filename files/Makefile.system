
###############################################################
# ITEMS ONLY NEEDED FOR BUILD, NOT FOR USER
###############################################################

hppfiles:
	@echo "HPPFILES = $(HPPFILES)"

cleanall: clean 
	\cd $(DIR_MATRICKS)/examples && make clean
	\cd $(DIR_MATRICKS)/errorexamples && make clean
	\cd $(DIR_MATRICKS)/testbed && make clean
	\cd $(DIR_MATRICKS)/benchmarks && make clean
	\cd $(DIR_MATRICKS)/development && make clean
	\cd $(DIR_MATRICKS)/doc && make clean
	\cd $(DIR_MATRICKS)/src && make clean

fullpurge: cleanall
	\rm -f $(DIR_MATRICKS)/*~
	\rm -f $(DIR_MATRICKS)/*.gz
	\rm -f $(DIR_MATRICKS)/*.tar
	\rm -f $(DIR_MATRICKS)/*.old
	\rm -f $(DIR_MATRICKS)/*/*~
	\rm -f $(DIR_MATRICKS)/*/*.old
	\rm -fr $(DIR_MATRICKS)/lib


#############################################################
# git related and versioning
#############################################################

# output files
TAG_ONELINE_SUMMARY_FILE = $(DIR_MATRICKS)/files/matricks.tag.onelinesummary
TAG_ANNOTATION_FILE = $(DIR_MATRICKS)/files/matricks.tag.annotation



# retrieve the Major.Minor version from the file
# and then calculate the revision number (number of commits since version has been changed)

define calcVersion
. $(VERSION_FILE_MATRICKS) && \
echo -e " "$(BLUE)"VERSION_MATRICKS"$(DEFCLR)=$(BOLDON)$${VERSION_MATRICKS}$(BOLDOFF) &&\
TAG=v$${VERSION_MATRICKS} ;\
VERSION_COMMIT_COUNT=`git tag -l "$$TAG*" | wc -l | tr -d ' '` &&\
echo -e " "$(BLUE)VERSION_COMMIT_COUNT$(DEFCLR)=$(BOLDON)$${VERSION_COMMIT_COUNT}$(BOLDOFF) &&\
if [[ $${VERSION_COMMIT_COUNT} -gt 0 ]]; then TAG=$${TAG}"-r"$${VERSION_COMMIT_COUNT}; fi ;\
echo -e " "$(BLUE)TAG$(DEFCLR)=$(BOLDON)$${TAG}$(BOLDOFF) ;\
echo $${TAG} > $(TAG_FILE_MATRICKS)
endef


define commit
read -r -p "Would you like to commit these changes and push to githib [y/N] ? " response ;\
response=$${response,,}  ;\
if [[ $$response =~ ^(|n|no)$$ ]]; then \
 echo "Exiting with no action taken" ;\
else (\
 git commit; \
 git tag --file=$(TAG_ANNOTATION_FILE) --cleanup verbatim `cat $(TAG_FILE_MATRICKS)`;\
 git push --tags origin `git branch | grep '\*' | cut -f2 -d' '` );\
fi 
endef



pull_all: pull 

pull:
	git pull origin master

git:
	@echo
	@git remote update origin
	@if [[ $$(git fetch --dry-run) ]]; then (echo "Your local repo is NOT up-to-date: execute 'git pull' first";exit 1) ; else echo "Your local repo is up-to-date"; fi
	@$(call calcVersion)
	@echo -e "Tag for this commit: "$(BOLDON)`cat $(TAG_FILE_MATRICKS)` $(BOLDOFF)
	@echo > $(TAG_ONELINE_SUMMARY_FILE) 
	@cat $(TAG_ONELINE_SUMMARY_FILE) > $(TAG_ANNOTATION_FILE)
	@cat $(TAG_FILE_MATRICKS) >> $(TAG_ANNOTATION_FILE)
	@cat  $(VERSION_FILE_MATRICKS) >> $(TAG_ANNOTATION_FILE)
	@git add $(TAG_FILE_MATRICKS) $(TAG_ANNOTATION_FILE)
	@$(shell TAG=`cat $(TAG_FILE_MATRICKS)` && echo "const char vers_matricks[] = \"$${TAG}\";" > $(VERSION_HEADER_FILE_MATRICKS) )
	@git add $(VERSION_HEADER_FILE_MATRICKS)
	@echo
	@git status 
	@echo 
	@echo "THE FOLLOWING COMMANDS WILL BE EXECUTED:"
	@echo "git commit"
	@echo "git tag --file=$(TAG_ANNOTATION_FILE) --cleanup verbatim $$(tput setaf 6)`cat $(TAG_FILE_MATRICKS)`$$(tput sgr 0)"
	@echo "git push --tags origin $$(tput setaf 6)`git branch | grep '\*' | cut -f2 -d' '`$$(tput sgr 0)"
	@echo 
	@echo
	@$(call commit)
